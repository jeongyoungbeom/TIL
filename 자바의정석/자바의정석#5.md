## 인터페이스
일종의 추상클래스이다. 
추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
**오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외에 다른 어떠한 요소도 허용하지 않는다.**

추상클래스가 부분적으로만 완성된 '미완성 설계도'라면 인터페이스는 구현된 것은 아무것도 없고  밑그림만 그려져 있는 '기본 설계도'라 할 수 있다.

### 인터페이스의 작성
작성하는 것은 클래스를 작성하는 것과 같다. 다만 키워드로 class 대신 interface를 사용한다는 것만 다르다.
클래스와 같이 접근제어자로 public 또는 default를 사용할 수 있다.

```java
interface 인터페이스이름 {
	public static final 타입 상수이름 = 값;
    	public abstract 메서드이름(매개변수목록);
}
```
인터페이스의 멤버의 제약사항
```
모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
단. static메서드와 default 메서드는 예외(JDK1.8부터 사용가능하다.)
```
인터페이스에 정의된 모든 멤버에 예외없이 적용되는 사항이기 때문에 제어자를 생략할 수 있는 것이며, 편의상 생략하는 경우가 많다. 생략된 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다.

### 인터페이스의 상속
클래스와 달리 다중상속이 가능하다. 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능하다 라는 것이다.
```인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.```

```java
public interface Movable {
    void move(int x, int y);
}

interface Attackable {
    void attack(Unit u);
}

interface Fightable extends Movable, Attackable {
}
```

### 인터페이스의 구현
추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야한다. 그래서 **인터페이스를 구현한다는 의미의 키워드인 'implements'를 사용한다.**
```java
class 클래스이름 implements 인터페이스 이름 {
	// 인터페이스에 정의된 추상메서드를 구현해야 한다.
}

class Fighter implements Fightable {
	public void move(int x, int y) {}
    public void attack(Unit u) {}
}
```
```이 때 'Fighter클래스는 Fightable인터페이스를 구현한다'라고 한다.```

만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.
```java
abstract class Fighter implements Fightable {
	public void move(int x, int y) {}
}
```
그리고 상속과 구현을 동시에 사용할 수도 있다.
```java
class Fighter extends Unit implements Fightable{
	public void move(int x, int y) {}
    public void attack(Unit u) {}
}
```

```
인터페이스 명은 대부분 "~을 할 수 있는"의 의미인 able로 끝나는 것들이 많다고 한다.
그 이유는 어떤 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서다.
때문에 그 인터페이스를 구현하는 클래스는 "~를 할 수 있는" 능력을 갖추었다는 의미이기도 하다.
이름이 'able'로 끝나는 것은 인터페이스라고 추측할 수 있지만, 모든 인터페이스의 이름이 반드시 'able'로 끝나야 하는것은 아니다. 
```
### 인터페이스를 이용한 다형성
클래스와 같이 인터페이스 역시 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로 형변환도 가능하다.

인터페이스  Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter 인스턴스를 Fightable타입의 참조변수로 참조하는 것이 가능하다.

```java
Fightable f = (Fightable)new Fighter();
또는
Fightable f = new Fighter();
```
따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로 사용될 수 있다.
```java
void attack(Fightable f) {
	//
}
```

그리고 다음과 같이 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것이 가능하다.
```java
Fightable method() {
	...
    Fighter f = new Fighter();
    return f;
}
```
**리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것이다.**

### 인터페이스의 장점
개발시간을 단축시킬 수 있다.

	인터페이스를 작성되면 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알며 되기 때문에 프로그램을 작성하는것이 가능하다.
    그리고 동시에 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 되면, 인터페이스를 구현하는 클래스가 작성될 때 까지 기다리지 않고도 양쪽에서 동시에 개발이 가능하다. 
    
표준화가 가능하다.

	기본 틀을 인터페이스로 작성한 뒤, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
    

서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.

	서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록하여 관계를 맺을 수 있다.

독립적인 프로그래밍이 가능하다.

	인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.

